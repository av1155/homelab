name: CI ‚Äî Validate Stacks, Security & Lint

on:
    pull_request:
        branches: ["main"]
    schedule:
        - cron: "0 14 * * *" # Scheduled security runs at 14:00 UTC
    workflow_dispatch:

permissions:
    contents: read

concurrency:
    group: ci-${{ github.ref }}
    cancel-in-progress: true

env:
    STACKS_DIR: stacks
    BROKEN_CACHE_PATH: .ci/broken-stacks.json
    NODE_VERSION: "20"
    YQ_VERSION: "v4.44.2"
    TRUFFLEHOG_VERSION: "v3.90.5"

defaults:
    run:
        shell: bash

jobs:
    # 1) Fast, repo-wide checks that can run immediately and in parallel
    meta_lint:
        name: Lint ‚Äî Workflows and Docs
        runs-on: ubuntu-latest
        timeout-minutes: 10
        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Install actionlint (pinned downloader)
              run: |
                  set -euo pipefail
                  curl -sSL https://raw.githubusercontent.com/rhysd/actionlint/main/scripts/download-actionlint.bash \
                    | bash -s -- latest /usr/local/bin
                  actionlint --version

            - name: Lint GitHub workflows (actionlint)
              run: |
                  set -euo pipefail
                  actionlint -color -shellcheck= -pyflakes= 2>&1 | tee actionlint.log

            - name: Set up Node
              uses: actions/setup-node@v4
              with:
                  node-version: ${{ env.NODE_VERSION }}

            - name: Install markdownlint
              run: |
                  set -euo pipefail
                  if [ ! -f package.json ]; then npm init -y >/dev/null 2>&1; fi
                  npm i -D markdownlint@0.38.0

            - name: Lint README (markdownlint)
              id: markdownlint
              uses: DavidAnson/markdownlint-cli2-action@v16
              with:
                  globs: README.md
                  config: .markdownlint.json
              continue-on-error: true

            - name: Capture markdownlint status
              if: always()
              run: |
                  [[ "${{ steps.markdownlint.outcome }}" == "success" ]] && echo "0" > markdownlint.status || echo "1" > markdownlint.status

            - name: Summary
              if: always()
              run: |
                  {
                    echo "### üìù Meta Lint"
                    if [[ "${{ job.status }}" == "success" ]]; then
                      echo "- actionlint ‚úÖ"
                      if [[ -f markdownlint.status && "$(cat markdownlint.status)" == "0" ]]; then
                        echo "- markdownlint ‚úÖ"
                      else
                        echo "- markdownlint ‚ùå"
                      fi
                    else
                      echo "- Linting ‚ùå"
                      if [[ -f actionlint.log ]]; then
                        echo
                        echo "<details><summary>actionlint (last lines)</summary>"
                        tail -n 10 actionlint.log
                        echo "</details>"
                      fi
                    fi
                  } >> "$GITHUB_STEP_SUMMARY"

    security_secrets:
        name: Security ‚Äî Secrets
        runs-on: ubuntu-latest
        timeout-minutes: 15
        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Install TruffleHog
              run: |
                  set -euo pipefail
                  curl -sSfL "https://raw.githubusercontent.com/trufflesecurity/trufflehog/${TRUFFLEHOG_VERSION}/scripts/install.sh" | sh
                  echo "$PWD/bin" >> "$GITHUB_PATH"

            - name: Scan for secrets in ${{ env.STACKS_DIR }}/
              run: |
                  set -euo pipefail
                  trufflehog filesystem --no-update --only-verified --fail "${STACKS_DIR}" 2>&1 | tee trufflehog.log

            - name: Summary
              if: always()
              run: |
                  {
                    echo "### üîë Security (secrets)"
                    if [[ "${{ job.status }}" == "success" ]]; then
                      echo "- TruffleHog ‚úÖ ‚Äî no verified secrets"
                    else
                      echo "- TruffleHog ‚ùå ‚Äî potential secrets detected"
                      if [[ -f trufflehog.log ]]; then
                        echo
                        echo "<details><summary>TruffleHog output (last lines)</summary>"
                        tail -n 10 trufflehog.log
                        echo "</details>"
                      fi
                    fi
                  } >> "$GITHUB_STEP_SUMMARY"

    # 2) Change detection branch (feeds matrix validation)
    detect_changes:
        name: Detect ‚Äî Changed Stacks
        runs-on: ubuntu-latest
        timeout-minutes: 5
        outputs:
            have_changes: ${{ steps.changed.outputs.have_changes }}
            matrix: ${{ steps.changed.outputs.matrix }}
        steps:
            - name: Checkout
              uses: actions/checkout@v4
              with:
                  fetch-depth: 2

            - name: Restore broken stacks cache
              id: broken_cache
              uses: actions/cache/restore@v4
              with:
                  path: ${{ env.BROKEN_CACHE_PATH }}
                  key: broken-stacks
                  restore-keys: |
                      broken-stacks-

            - name: Install jq
              run: |
                  sudo apt-get update
                  sudo apt-get install -y jq

            - name: Compute changed stacks
              id: changed
              run: |
                  set -euo pipefail

                  if [[ "${{ github.event_name }}" == "pull_request" ]]; then
                    git fetch --no-tags --depth=1 origin "${{ github.base_ref }}"
                    BASE="origin/${{ github.base_ref }}"
                  else
                    if git rev-parse HEAD~1 >/dev/null 2>&1; then
                      BASE="HEAD~1"
                    else
                      BASE="$(git hash-object -t tree /dev/null)"
                    fi
                  fi

                  CHANGED_STACKS="$(git diff --name-only "$BASE"...HEAD | grep -E '^'"${STACKS_DIR}"'/[^/]+/' || true)"
                  CHANGED_NAMES="$(printf "%s\n" "$CHANGED_STACKS" | awk -F/ 'NF>1 {print $2}' | sort -u)"

                  if [[ -f "${BROKEN_CACHE_PATH}" ]]; then
                    BROKEN_NAMES="$(jq -r '.stack[]?' "${BROKEN_CACHE_PATH}" | sort -u)"
                  else
                    BROKEN_NAMES=""
                  fi

                  ALL_NAMES="$(printf "%s\n%s\n" "$CHANGED_NAMES" "$BROKEN_NAMES" | awk NF | sort -u)"

                  EXISTING_NAMES="$(printf "%s\n" "$ALL_NAMES" | awk NF | while read -r n; do [[ -d "${STACKS_DIR}/$n" ]] && echo "$n"; done | sort -u)"
                  MISSING_NAMES="$(printf "%s\n" "$ALL_NAMES" | awk NF | while read -r n; do [[ ! -d "${STACKS_DIR}/$n" ]] && echo "$n"; done | sort -u)"

                  if [[ -n "$EXISTING_NAMES" ]]; then
                    MATRIX="$(jq -n --arg s "$EXISTING_NAMES" '($s|split("\n")|map(select(length>0))) | {stack: .}')"
                    {
                      echo "matrix<<EOF"
                      echo "$MATRIX"
                      echo "EOF"
                    } >> "$GITHUB_OUTPUT"
                    echo "have_changes=true" >> "$GITHUB_OUTPUT"
                  else
                    echo 'matrix={"stack":[]}' >> "$GITHUB_OUTPUT"
                    echo "have_changes=false" >> "$GITHUB_OUTPUT"
                  fi

                  {
                    echo "## üîç Change Detection"
                    if [[ -n "$EXISTING_NAMES" ]]; then
                      echo "- Stacks to validate: \`$(echo "$EXISTING_NAMES" | tr '\n' ' ')\` ‚úÖ"
                    else
                      echo "- No stacks to validate ‚úÖ"
                    fi
                    if [[ -n "$MISSING_NAMES" ]]; then
                      echo "- Skipping removed/renamed stacks (not on disk): \`$(echo "$MISSING_NAMES" | tr '\n' ' ')\`"
                    fi
                  } >> "$GITHUB_STEP_SUMMARY"

    validate_stacks:
        name: Validate ‚Äî Docker and YAML (per stack)
        needs: detect_changes
        if: needs.detect_changes.outputs.have_changes == 'true'
        runs-on: ubuntu-latest
        timeout-minutes: 20
        strategy:
            fail-fast: false
            matrix: ${{ fromJson(needs.detect_changes.outputs.matrix) }}
        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Check if stack directory exists
              id: exists
              run: |
                  if [[ ! -d "${STACKS_DIR}/${{ matrix.stack }}" ]]; then
                    echo "skip=true" >> "$GITHUB_OUTPUT"
                  else
                    echo "skip=false" >> "$GITHUB_OUTPUT"
                  fi

            - name: Set up Docker Buildx
              if: steps.exists.outputs.skip != 'true'
              uses: docker/setup-buildx-action@v3

            - name: Install tools (yamllint, jq)
              if: steps.exists.outputs.skip != 'true'
              run: |
                  set -euo pipefail
                  sudo apt-get update
                  sudo apt-get install -y yamllint jq

            - name: Lint YAML in ${{ env.STACKS_DIR }}/${{ matrix.stack }}
              if: steps.exists.outputs.skip != 'true'
              run: |
                  set -euo pipefail
                  yamllint "${STACKS_DIR}/${{ matrix.stack }}" 2>&1 | tee yamllint.log

            - name: Validate docker-compose files in ${{ env.STACKS_DIR }}/${{ matrix.stack }}
              if: steps.exists.outputs.skip != 'true'
              run: |
                  set -euo pipefail
                  mapfile -d '' files < <(find "${STACKS_DIR}/${{ matrix.stack }}" -name "docker-compose.yaml" -print0 || true)
                  if (( ${#files[@]} == 0 )); then
                    echo "No docker-compose.yaml in ${STACKS_DIR}/${{ matrix.stack }}"
                    exit 0
                  fi

                  failed=0
                  : > compose-validate.log
                  for f in "${files[@]}"; do
                    echo "Validating $f" | tee -a compose-validate.log
                    if ! docker compose -f "$f" config --no-interpolate 2>> compose-validate.log; then
                      failed=1
                    fi
                  done

                  (( failed == 0 ))

            - name: Summary
              if: always()
              run: |
                  {
                    echo "### ‚úÖ Validation summary for \`${STACKS_DIR}/${{ matrix.stack }}\`"
                    if [[ "${{ steps.exists.outputs.skip }}" == "true" ]]; then
                      echo "- Skipped: directory not found (likely renamed or removed)"
                    elif [[ "${{ job.status }}" == "success" ]]; then
                      echo "- YAML lint ‚úÖ"
                      echo "- Compose config ‚úÖ"
                    else
                      echo "- One or more validation checks ‚ùå"
                      if [[ -f compose-validate.log ]]; then
                        echo
                        echo "<details><summary>Compose validation (last lines)</summary>"
                        tail -n 20 compose-validate.log
                        echo "</details>"
                      fi
                      if [[ -f yamllint.log ]]; then
                        echo
                        echo "<details><summary>YAML lint (last lines)</summary>"
                        tail -n 20 yamllint.log
                        echo "</details>"
                      fi
                    fi
                  } >> "$GITHUB_STEP_SUMMARY"

            - name: Mark stack as broken/fixed
              if: always()
              run: |
                  set -euo pipefail
                  mkdir -p .ci
                  if [[ -f "${BROKEN_CACHE_PATH}" ]]; then
                    cp "${BROKEN_CACHE_PATH}" .ci/_broken.json
                  else
                    echo '{"stack":[]}' > .ci/_broken.json
                  fi

                  # If the directory is gone, remove it from cache.
                  if [[ "${{ steps.exists.outputs.skip }}" == "true" ]]; then
                    jq --arg s "${{ matrix.stack }}" \
                      ' .stack -= [ $s ] | {stack: ( .stack // [] | unique ) }' \
                      .ci/_broken.json > "${BROKEN_CACHE_PATH}"
                  elif [[ "${{ job.status }}" == "success" ]]; then
                    jq --arg s "${{ matrix.stack }}" \
                      ' .stack -= [ $s ] | {stack: ( .stack // [] | unique ) }' \
                      .ci/_broken.json > "${BROKEN_CACHE_PATH}"
                  else
                    jq --arg s "${{ matrix.stack }}" \
                      ' .stack += [ $s ] | {stack: ( .stack // [] | unique ) }' \
                      .ci/_broken.json > "${BROKEN_CACHE_PATH}"
                  fi

            - name: Upload broken-stacks part
              if: always()
              uses: actions/upload-artifact@v4
              with:
                  name: broken-stacks-part-${{ matrix.stack }}
                  path: ${{ env.BROKEN_CACHE_PATH }}
                  retention-days: 3

            - name: Upload validation logs (on failure)
              if: failure() && steps.exists.outputs.skip != 'true' && (hashFiles('compose-validate.log','yamllint.log') != '')
              uses: actions/upload-artifact@v4
              with:
                  name: validation-logs-${{ matrix.stack }}-${{ github.run_id }}-${{ github.run_attempt }}
                  path: |
                      compose-validate.log
                      yamllint.log
                  retention-days: 14

    # 3) Persist sticky failures regardless of matrix outcome
    persist_broken_cache:
        name: Cache ‚Äî Broken Stacks
        needs: [detect_changes, validate_stacks]
        if: always()
        runs-on: ubuntu-latest
        timeout-minutes: 5
        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Restore previous cache
              id: prev_cache
              uses: actions/cache/restore@v4
              with:
                  path: ${{ env.BROKEN_CACHE_PATH }}
                  key: broken-stacks
                  restore-keys: |
                      broken-stacks-

            - name: Download broken-stacks parts
              uses: actions/download-artifact@v4
              continue-on-error: true
              with:
                  pattern: broken-stacks-part-*
                  merge-multiple: false
                  path: .ci/parts

            - name: Install jq
              run: |
                  sudo apt-get update
                  sudo apt-get install -y jq

            - name: Merge parts into cache
              run: |
                  set -euo pipefail
                  mkdir -p .ci

                  # Start from previous cache if present, else empty
                  if [[ -f "${BROKEN_CACHE_PATH}" ]]; then
                    jq -c '.stack // []' "${BROKEN_CACHE_PATH}" > .ci/_merged.list
                  else
                    echo "[]" > .ci/_merged.list
                  fi

                  add_stack() {
                    jq -c --arg s "$1" '. + [$s] | unique' .ci/_merged.list > .ci/_tmp.list
                    mv .ci/_tmp.list .ci/_merged.list
                  }
                  remove_stack() {
                    jq -c --arg s "$1" 'map(select(. != $s))' .ci/_merged.list > .ci/_tmp.list
                    mv .ci/_tmp.list .ci/_merged.list
                  }

                  # Merge artifact parts
                  while IFS= read -r -d '' f; do
                    artifact_dir="$(dirname "$f")"
                    stack=""
                    while [[ "$artifact_dir" != "/" && "$artifact_dir" != "." ]]; do
                      candidate="$(basename "$artifact_dir")"
                      if [[ "$candidate" == broken-stacks-part-* ]]; then
                        stack="${candidate#broken-stacks-part-}"
                        break
                      fi
                      artifact_dir="$(dirname "$artifact_dir")"
                    done

                    if [[ -z "$stack" ]]; then
                      current="$(jq -c '.stack // []' "$f")"
                      jq -c --argjson cur "$current" '(. + $cur) | unique' .ci/_merged.list > .ci/_tmp.list
                      mv .ci/_tmp.list .ci/_merged.list
                      echo "Merged (legacy) from $f"
                      continue
                    fi

                    if jq -e --arg s "$stack" '(.stack // []) | index($s)' "$f" >/dev/null; then
                      add_stack "$stack"
                      echo "Added $stack (from $f)"
                    else
                      remove_stack "$stack"
                      echo "Removed $stack (from $f)"
                    fi
                  done < <(find .ci/parts -type f -name broken-stacks.json -print0)

                  # Write final merged cache
                  jq -c '{stack: .}' .ci/_merged.list > "${BROKEN_CACHE_PATH}"

                  if [[ -f "${BROKEN_CACHE_PATH}" ]]; then
                    mapfile -t _cur < <(jq -r '.stack[]?' "${BROKEN_CACHE_PATH}" 2>/dev/null || true)
                    : > .ci/_keep.list
                    for s in "${_cur[@]}"; do
                      if [[ -d "${STACKS_DIR}/${s}" ]]; then
                        echo "$s" >> .ci/_keep.list
                      else
                        echo "Pruned non-existent stack from cache: $s"
                      fi
                    done
                    jq -c '{stack: ( [inputs] | map(select(length>0)) )}' .ci/_keep.list > "${BROKEN_CACHE_PATH}" <<<""
                    # If keep.list is empty, ensure proper shape
                    if [[ ! -s "${BROKEN_CACHE_PATH}" ]]; then
                      echo '{"stack":[]}' > "${BROKEN_CACHE_PATH}"
                    fi
                  fi

                  echo "Merged cache:"; cat "${BROKEN_CACHE_PATH}"

                  # Sanity check: ensure file has correct shape
                  jq -e 'type == "object" and (.stack | type == "array")' "${BROKEN_CACHE_PATH}" >/dev/null

                  {
                    echo "### ‚ôªÔ∏è Broken-stacks cache"
                    echo "- After merge: $(jq -r '.stack|length' "${BROKEN_CACHE_PATH}")"
                    echo
                    echo "#### Preview (up to 10)"
                    jq -r '.stack[:10][] | "- \(. )"' "${BROKEN_CACHE_PATH}"
                  } >> "$GITHUB_STEP_SUMMARY"

            - name: Save merged cache
              uses: actions/cache/save@v4
              with:
                  path: ${{ env.BROKEN_CACHE_PATH }}
                  key: broken-stacks-${{ github.run_id }}

    # 4) Image security
    security_images:
        name: Security ‚Äî Container Images
        if: ${{ !cancelled() }}
        runs-on: ubuntu-latest
        timeout-minutes: 25
        permissions:
            contents: read
            actions: write
        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Install yq
              run: |
                  sudo wget -qO /usr/local/bin/yq "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64"
                  sudo chmod +x /usr/local/bin/yq

            - name: Collect unique images from compose files
              id: collect
              run: |
                  set -euo pipefail
                  > images.txt
                  if ! find "${STACKS_DIR}" -name "docker-compose.yaml" | grep -q .; then
                    echo "No docker-compose.yaml files found."
                    echo "count=0" >> "$GITHUB_OUTPUT"
                    {
                      echo "## üì¶ Image Inventory"
                      echo "- Total images: \`0\`"
                      echo
                      echo "### Preview (up to 10 images)"
                    } >> "$GITHUB_STEP_SUMMARY"
                    exit 0
                  fi

                  while IFS= read -r -d '' f; do
                    yq -r '.services[]? | .image? // ""' "$f"
                  done < <(find "${STACKS_DIR}" -name "docker-compose.yaml" -print0) \
                    | grep -v '^$' | sort -u > images.txt
                  count="$(wc -l < images.txt | xargs || echo 0)"
                  echo "count=$count" >> "$GITHUB_OUTPUT"

                  {
                    echo "## üì¶ Image Inventory"
                    echo "- Total images: \`$count\`"
                    echo
                    echo "### Preview (up to 10 images)"
                    head -n 10 images.txt | sed 's/^/- /' || true
                  } >> "$GITHUB_STEP_SUMMARY"

            - name: Compute cache epoch (weekly)
              run: |
                  set -euo pipefail
                  echo "CACHE_EPOCH=$(date -u +%G-%V)" >> "$GITHUB_ENV"

            - name: Restore Trivy DB cache
              id: trivy_restore
              uses: actions/cache/restore@v4
              with:
                  path: ~/.cache/trivy
                  key: trivy-db-${{ runner.os }}-W${{ env.CACHE_EPOCH }}-v1
                  restore-keys: |
                      trivy-db-${{ runner.os }}-

            - name: Install Trivy (CLI)
              run: |
                  set -euo pipefail
                  curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh \
                    | sudo sh -s -- -b /usr/local/bin

            - name: Scan images with Trivy (CRITICAL only)
              if: steps.collect.outputs.count != '0'
              run: |
                  set -euo pipefail
                  failed=0
                  : > trivy.log
                  while read -r img; do
                    [[ -z "$img" ]] && continue
                    echo "::group::Trivy scan $img"
                    trivy image --scanners vuln --severity CRITICAL --ignore-unfixed --no-progress "$img" 2>&1 | tee -a trivy.log || failed=1
                    echo "::endgroup::"
                  done < images.txt
                  (( failed == 0 ))

            - name: Save Trivy DB cache
              if: ${{ (github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/main')) && steps.trivy_restore.outputs.cache-hit != 'true' }}
              uses: actions/cache/save@v4
              with:
                  path: ~/.cache/trivy
                  key: trivy-db-${{ runner.os }}-W${{ env.CACHE_EPOCH }}-v1

            - name: Prune old Trivy caches (keep last 4)
              env:
                  GH_TOKEN: ${{ github.token }}
              run: |
                  set -euo pipefail
                  sudo apt-get update -y
                  sudo apt-get install -y jq >/dev/null 2>&1 || true

                  if ! command -v gh >/dev/null; then
                    curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg \
                      | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg
                    sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg
                    echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" \
                      | sudo tee /etc/apt/sources.list.d/github-cli.list >/dev/null
                    sudo apt-get update -y
                    sudo apt-get install -y gh || { echo "WARN: gh install failed; skipping prune."; exit 0; }
                  fi

                  gh extension install actions/gh-actions-cache || true

                  REPO="${GITHUB_REPOSITORY}"
                  PREFIX="trivy-db-${RUNNER_OS}-"

                  keys=$(gh actions-cache list -R "$REPO" \
                    | awk '{print $1}' \
                    | grep -E "^${PREFIX}" \
                    | sort || true)

                  keep=4
                  to_delete=$(printf "%s\n" "$keys" | awk 'NF' | tail -n +"$((keep+1))" || true)

                  if [[ -n "${to_delete}" ]]; then
                    echo "Pruning old Trivy caches:"
                    printf "%s\n" "${to_delete}" | while read -r k; do
                      echo " - $k"
                      gh actions-cache delete "$k" -R "$REPO" --confirm || true
                    done
                  else
                    echo "No old Trivy caches to prune (have ‚â§ ${keep})."
                  fi

            - name: Summary
              if: always()
              run: |
                  {
                    echo "### üõ° Security (images)"
                    if [[ "${{ job.status }}" == "success" ]]; then
                      echo "- Trivy scan ‚úÖ ‚Äî no CRITICAL vulns found"
                    else
                      echo "- Trivy scan ‚ùå ‚Äî CRITICAL vulns detected"
                      if [[ -f trivy.log ]]; then
                        echo
                        echo "<details><summary>Trivy output (last lines)</summary>"
                        tail -n 10 trivy.log
                        echo "</details>"
                      fi
                    fi
                  } >> "$GITHUB_STEP_SUMMARY"

    verified_summary:
        name: CI Gate ‚Äî All Checks Passed
        needs:
            - meta_lint
            - security_secrets
            - security_images
            - validate_stacks
            - persist_broken_cache
        runs-on: ubuntu-latest
        timeout-minutes: 10
        if: ${{ always() && !cancelled() }}
        steps:
            - name: Evaluate required jobs
              run: |
                  set -euo pipefail
                  declare -A RES=(
                    [meta_lint]="${{ needs.meta_lint.result }}"
                    [security_secrets]="${{ needs.security_secrets.result }}"
                    [security_images]="${{ needs.security_images.result }}"
                    [validate_stacks]="${{ needs.validate_stacks.result }}"
                    [persist_broken_cache]="${{ needs.persist_broken_cache.result }}"
                  )
                  fail=0
                  require_success () {
                    local name="$1" res="$2"
                    if [[ "$name" == "validate_stacks" && "$res" == "skipped" ]]; then
                      return 0
                    fi
                    if [[ "$res" != "success" ]]; then
                      echo "::error title=Gate failed::Job '${name}' result: ${res}"
                      fail=1
                    fi
                  }
                  for name in "${!RES[@]}"; do
                    require_success "$name" "${RES[$name]}"
                  done
                  {
                    echo "### ‚úÖ Verified Summary (CI Gate)"
                    for name in meta_lint security_secrets security_images validate_stacks persist_broken_cache; do
                      res="${RES[$name]}"
                      sym="‚úÖ"
                      if [[ "$res" != "success" && ! ( "$name" == "validate_stacks" && "$res" == "skipped" ) ]]; then
                        sym="‚ùå"
                      fi
                      echo "- **${name}**: \`${res}\` $sym"
                    done
                  } >> "$GITHUB_STEP_SUMMARY"
                  exit $fail
