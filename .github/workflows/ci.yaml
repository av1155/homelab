name: CI ‚Äî Validate Stacks, Security & Lint

on:
    pull_request:
        branches: ["main"]
    schedule:
        - cron: "0 14 * * *" # Scheduled security runs at 14:00 UTC
    workflow_dispatch:

permissions:
    contents: read

concurrency:
    group: ci-${{ github.ref }}
    cancel-in-progress: true

env:
    STACKS_DIR: stacks
    BROKEN_CACHE_PATH: .ci/broken-stacks.json
    NODE_VERSION: "20"
    YQ_VERSION: "v4.44.2"
    TRUFFLEHOG_VERSION: "v3.90.5"

defaults:
    run:
        shell: bash

jobs:
    # 1) Fast, repo-wide checks that can run immediately and in parallel
    meta_lint:
        name: Meta lint (workflows + README)
        runs-on: ubuntu-latest
        timeout-minutes: 10
        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Install actionlint (pinned downloader)
              run: |
                  set -euo pipefail
                  curl -sSL https://raw.githubusercontent.com/rhysd/actionlint/main/scripts/download-actionlint.bash \
                    | bash -s -- latest /usr/local/bin
                  actionlint --version

            - name: Lint GitHub workflows (actionlint)
              run: |
                  set -euo pipefail
                  actionlint -color -shellcheck= -pyflakes= 2>&1 | tee actionlint.log

            - name: Set up Node
              uses: actions/setup-node@v4
              with:
                  node-version: ${{ env.NODE_VERSION }}

            - name: Install markdownlint
              run: |
                  set -euo pipefail
                  if [ ! -f package.json ]; then npm init -y >/dev/null 2>&1; fi
                  npm i -D markdownlint@0.38.0

            - name: Lint README (markdownlint)
              id: markdownlint
              uses: DavidAnson/markdownlint-cli2-action@v16
              with:
                  globs: README.md
                  config: .markdownlint.json
              continue-on-error: true

            - name: Capture markdownlint status
              if: always()
              run: |
                  [[ "${{ steps.markdownlint.outcome }}" == "success" ]] && echo "0" > markdownlint.status || echo "1" > markdownlint.status

            - name: Summary
              if: always()
              run: |
                  {
                    echo "### üìù Meta Lint"
                    if [[ "${{ job.status }}" == "success" ]]; then
                      echo "- actionlint ‚úÖ"
                      if [[ -f markdownlint.status && "$(cat markdownlint.status)" == "0" ]]; then
                        echo "- markdownlint ‚úÖ"
                      else
                        echo "- markdownlint ‚ùå"
                      fi
                    else
                      echo "- Linting ‚ùå"
                      if [[ -f actionlint.log ]]; then
                        echo
                        echo "<details><summary>actionlint (last lines)</summary>"
                        tail -n 10 actionlint.log
                        echo "</details>"
                      fi
                    fi
                  } >> "$GITHUB_STEP_SUMMARY"

    security_secrets:
        name: Security scan (secrets)
        runs-on: ubuntu-latest
        timeout-minutes: 15
        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Install TruffleHog
              run: |
                  set -euo pipefail
                  curl -sSfL "https://raw.githubusercontent.com/trufflesecurity/trufflehog/${TRUFFLEHOG_VERSION}/scripts/install.sh" | sh
                  echo "$PWD/bin" >> "$GITHUB_PATH"

            - name: Scan for secrets in ${{ env.STACKS_DIR }}/
              run: |
                  set -euo pipefail
                  trufflehog filesystem --no-update --only-verified --fail "${STACKS_DIR}" 2>&1 | tee trufflehog.log

            - name: Summary
              if: always()
              run: |
                  {
                    echo "### üîë Security (secrets)"
                    if [[ "${{ job.status }}" == "success" ]]; then
                      echo "- TruffleHog ‚úÖ ‚Äî no verified secrets"
                    else
                      echo "- TruffleHog ‚ùå ‚Äî potential secrets detected"
                      if [[ -f trufflehog.log ]]; then
                        echo
                        echo "<details><summary>TruffleHog output (last lines)</summary>"
                        tail -n 10 trufflehog.log
                        echo "</details>"
                      fi
                    fi
                  } >> "$GITHUB_STEP_SUMMARY"

    # 2) Change detection branch (feeds matrix validation)
    detect_changes:
        name: Detect changed stacks
        runs-on: ubuntu-latest
        timeout-minutes: 5
        outputs:
            have_changes: ${{ steps.changed.outputs.have_changes }}
            matrix: ${{ steps.changed.outputs.matrix }}
        steps:
            - name: Checkout
              uses: actions/checkout@v4
              with:
                  fetch-depth: 2

            - name: Restore broken stacks cache
              id: broken_cache
              uses: actions/cache/restore@v4
              with:
                  path: ${{ env.BROKEN_CACHE_PATH }}
                  key: broken-stacks-v2
                  restore-keys: |
                      broken-stacks-v2-

            - name: Install jq
              run: |
                  sudo apt-get update
                  sudo apt-get install -y jq

            - name: Compute changed stacks
              id: changed
              run: |
                  set -euo pipefail

                  if [[ "${{ github.event_name }}" == "pull_request" ]]; then
                    git fetch --no-tags --depth=1 origin "${{ github.base_ref }}"
                    BASE="origin/${{ github.base_ref }}"
                  else
                    if git rev-parse HEAD~1 >/dev/null 2>&1; then
                      BASE="HEAD~1"
                    else
                      BASE="$(git hash-object -t tree /dev/null)"
                    fi
                  fi

                  CHANGED_STACKS="$(git diff --name-only "$BASE"...HEAD | grep -E '^'"${STACKS_DIR}"'/[^/]+/' || true)"
                  CHANGED_NAMES="$(printf "%s\n" "$CHANGED_STACKS" | awk -F/ 'NF>1 {print $2}' | sort -u)"

                  if [[ -f "${BROKEN_CACHE_PATH}" ]]; then
                    BROKEN_NAMES="$(jq -r '.stack[]?' "${BROKEN_CACHE_PATH}" | sort -u)"
                  else
                    BROKEN_NAMES=""
                  fi

                  ALL_NAMES="$(printf "%s\n%s\n" "$CHANGED_NAMES" "$BROKEN_NAMES" | awk NF | sort -u)"

                  if [[ -n "$ALL_NAMES" ]]; then
                    MATRIX="$(jq -n --arg s "$ALL_NAMES" '($s|split("\n")|map(select(length>0))) | {stack: .}')"
                    {
                      echo "matrix<<EOF"
                      echo "$MATRIX"
                      echo "EOF"
                    } >> "$GITHUB_OUTPUT"
                    echo "have_changes=true" >> "$GITHUB_OUTPUT"
                  else
                    echo 'matrix={"stack":[]}' >> "$GITHUB_OUTPUT"
                    echo "have_changes=false" >> "$GITHUB_OUTPUT"
                  fi

                  {
                    echo "## üîç Change Detection"
                    if [[ -n "$ALL_NAMES" ]]; then
                      echo "- Stacks to validate: \`$(echo "$ALL_NAMES" | tr '\n' ' ')\` ‚úÖ"
                    else
                      echo "- No stacks to validate ‚úÖ"
                    fi
                  } >> "$GITHUB_STEP_SUMMARY"

    validate_stacks:
        name: Validate (per changed stack)
        needs: detect_changes
        if: needs.detect_changes.outputs.have_changes == 'true'
        runs-on: ubuntu-latest
        timeout-minutes: 20
        strategy:
            fail-fast: false
            matrix: ${{ fromJson(needs.detect_changes.outputs.matrix) }}
        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Set up Docker Buildx
              uses: docker/setup-buildx-action@v3

            - name: Install tools (yamllint, jq)
              run: |
                  set -euo pipefail
                  sudo apt-get update
                  sudo apt-get install -y yamllint jq

            - name: Lint YAML in ${{ env.STACKS_DIR }}/${{ matrix.stack }}
              run: |
                  set -euo pipefail
                  yamllint "${STACKS_DIR}/${{ matrix.stack }}" 2>&1 | tee yamllint.log

            - name: Validate docker-compose files in ${{ env.STACKS_DIR }}/${{ matrix.stack }}
              run: |
                  set -euo pipefail
                  mapfile -d '' files < <(find "${STACKS_DIR}/${{ matrix.stack }}" -name "docker-compose.yaml" -print0 || true)
                  if (( ${#files[@]} == 0 )); then
                    echo "No docker-compose.yaml in ${STACKS_DIR}/${{ matrix.stack }}"
                    exit 0
                  fi

                  failed=0
                  : > compose-validate.log
                  for f in "${files[@]}"; do
                    echo "Validating $f" | tee -a compose-validate.log
                    if ! docker compose -f "$f" config --no-interpolate 2>> compose-validate.log; then
                      failed=1
                    fi
                  done

                  (( failed == 0 ))

            - name: Summary
              if: always()
              run: |
                  {
                    echo "### ‚úÖ Validation summary for \`${STACKS_DIR}/${{ matrix.stack }}\`"
                    if [[ "${{ job.status }}" == "success" ]]; then
                      echo "- YAML lint ‚úÖ"
                      echo "- Compose config ‚úÖ"
                    else
                      echo "- One or more validation checks ‚ùå"
                      if [[ -f compose-validate.log ]]; then
                        echo
                        echo "<details><summary>Compose validation (last lines)</summary>"
                        tail -n 20 compose-validate.log
                        echo "</details>"
                      fi
                      if [[ -f yamllint.log ]]; then
                        echo
                        echo "<details><summary>YAML lint (last lines)</summary>"
                        tail -n 20 yamllint.log
                        echo "</details>"
                      fi
                    fi
                  } >> "$GITHUB_STEP_SUMMARY"

            - name: Mark stack as broken/fixed
              if: always()
              run: |
                  set -euo pipefail
                  mkdir -p .ci
                  if [[ -f "${BROKEN_CACHE_PATH}" ]]; then
                    cp "${BROKEN_CACHE_PATH}" .ci/_broken.json
                  else
                    echo '{"stack":[]}' > .ci/_broken.json
                  fi

                  if [[ "${{ job.status }}" == "success" ]]; then
                    jq --arg s "${{ matrix.stack }}" \
                      ' .stack -= [ $s ] | {stack: ( .stack // [] | unique ) }' \
                      .ci/_broken.json > "${BROKEN_CACHE_PATH}"
                  else
                    jq --arg s "${{ matrix.stack }}" \
                      ' .stack += [ $s ] | {stack: ( .stack // [] | unique ) }' \
                      .ci/_broken.json > "${BROKEN_CACHE_PATH}"
                  fi

            - name: Upload broken-stacks part
              if: always()
              uses: actions/upload-artifact@v4
              with:
                  name: broken-stacks-part-${{ matrix.stack }}
                  path: ${{ env.BROKEN_CACHE_PATH }}
                  retention-days: 3

            - name: Upload validation logs (on failure)
              if: failure() && (hashFiles('compose-validate.log','yamllint.log') != '')
              uses: actions/upload-artifact@v4
              with:
                  name: validation-logs-${{ matrix.stack }}-${{ github.run_id }}-${{ github.run_attempt }}
                  path: |
                      compose-validate.log
                      yamllint.log
                  retention-days: 14

    # 3) Persist sticky failures regardless of matrix outcome
    persist_broken_cache:
        name: Persist broken stacks cache
        needs: [detect_changes, validate_stacks]
        if: always()
        runs-on: ubuntu-latest
        timeout-minutes: 5
        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Restore previous cache
              id: prev_cache
              uses: actions/cache/restore@v4
              with:
                  path: ${{ env.BROKEN_CACHE_PATH }}
                  key: broken-stacks-v2
                  restore-keys: |
                      broken-stacks-v2-

            - name: Download broken-stacks parts
              uses: actions/download-artifact@v4
              continue-on-error: true
              with:
                  pattern: broken-stacks-part-*
                  merge-multiple: false
                  path: .ci/parts

            - name: Install jq
              run: |
                  sudo apt-get update
                  sudo apt-get install -y jq

            - name: Merge parts into cache
              run: |
                  set -euo pipefail
                  mkdir -p .ci

                  # Start from previous cache if present, else empty
                  if [[ -f "${BROKEN_CACHE_PATH}" ]]; then
                    jq -c '.stack // []' "${BROKEN_CACHE_PATH}" > .ci/_merged.list
                  else
                    echo "[]" > .ci/_merged.list
                  fi

                  # Helpers to add/remove a single stack from the merged list
                  add_stack() {
                    jq -c --arg s "$1" '. + [$s] | unique' .ci/_merged.list > .ci/_tmp.list
                    mv .ci/_tmp.list .ci/_merged.list
                  }
                  remove_stack() {
                    jq -c --arg s "$1" 'map(select(. != $s))' .ci/_merged.list > .ci/_tmp.list
                    mv .ci/_tmp.list .ci/_merged.list
                  }

                  # Find all broken-stacks.json files in any artifact
                  while IFS= read -r -d '' f; do
                    # Walk up until we find the artifact directory named "broken-stacks-part-*"
                    artifact_dir="$(dirname "$f")"
                    stack=""
                    while [[ "$artifact_dir" != "/" && "$artifact_dir" != "." ]]; do
                      candidate="$(basename "$artifact_dir")"
                      if [[ "$candidate" == broken-stacks-part-* ]]; then
                        stack="${candidate#broken-stacks-part-}"
                        break
                      fi
                      artifact_dir="$(dirname "$artifact_dir")"
                    done

                    if [[ -z "$stack" ]]; then
                      current="$(jq -c '.stack // []' "$f")"
                      jq -c --argjson cur "$current" '(. + $cur) | unique' .ci/_merged.list > .ci/_tmp.list
                      mv .ci/_tmp.list .ci/_merged.list
                      echo "Merged (legacy) from $f"
                      continue
                    fi

                    if jq -e --arg s "$stack" '(.stack // []) | index($s)' "$f" >/dev/null; then
                      jq -c --arg s "$stack" '. + [$s] | unique' .ci/_merged.list > .ci/_tmp.list
                      mv .ci/_tmp.list .ci/_merged.list
                      echo "Added $stack (from $f)"
                    else
                      jq -c --arg s "$stack" 'map(select(. != $s))' .ci/_merged.list > .ci/_tmp.list
                      mv .ci/_tmp.list .ci/_merged.list
                      echo "Removed $stack (from $f)"
                    fi
                  done < <(find .ci/parts -type f -name broken-stacks.json -print0)

                  # Write final merged cache
                  jq -c '{stack: .}' .ci/_merged.list > "${BROKEN_CACHE_PATH}"
                  echo "Merged cache:"; cat "${BROKEN_CACHE_PATH}"

                  # Sanity check: ensure file has correct shape
                  jq -e 'type == "object" and (.stack | type == "array")' "${BROKEN_CACHE_PATH}" >/dev/null

                  {
                    echo "### ‚ôªÔ∏è Broken-stacks cache"
                    echo "- After merge: $(jq -r '.stack|length' "${BROKEN_CACHE_PATH}")"
                    echo
                    echo "#### Preview (up to 10)"
                    jq -r '.stack[:10][] | "- \(. )"' "${BROKEN_CACHE_PATH}"
                  } >> "$GITHUB_STEP_SUMMARY"

            - name: Save merged cache
              uses: actions/cache/save@v4
              with:
                  path: ${{ env.BROKEN_CACHE_PATH }}
                  key: broken-stacks-v2-${{ github.run_id }}

    # 4) Image security ‚Äî gated inline (no separate gate job)
    security_images:
        name: Security scan (images only)
        if: ${{ !cancelled() }}
        runs-on: ubuntu-latest
        timeout-minutes: 25
        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Install yq
              run: |
                  sudo wget -qO /usr/local/bin/yq "https://github.com/mikefarah/yq/releases/download/${YQ_VERSION}/yq_linux_amd64"
                  sudo chmod +x /usr/local/bin/yq

            - name: Collect unique images from compose files
              id: collect
              run: |
                  set -euo pipefail
                  > images.txt
                  if ! find "${STACKS_DIR}" -name "docker-compose.yaml" | grep -q .; then
                    echo "No docker-compose.yaml files found."
                    echo "count=0" >> "$GITHUB_OUTPUT"
                    {
                      echo "## üì¶ Image Inventory"
                      echo "- Total images: \`0\`"
                      echo
                      echo "### Preview (up to 10 images)"
                    } >> "$GITHUB_STEP_SUMMARY"
                    exit 0
                  fi

                  while IFS= read -r -d '' f; do
                    yq -r '.services[]? | .image? // ""' "$f"
                  done < <(find "${STACKS_DIR}" -name "docker-compose.yaml" -print0) \
                    | grep -v '^$' \
                    | sort -u > images.txt

                  count="$(wc -l < images.txt | xargs || echo 0)"
                  echo "count=$count" >> "$GITHUB_OUTPUT"

                  {
                    echo "## üì¶ Image Inventory"
                    echo "- Total images: \`$count\`"
                    echo
                    echo "### Preview (up to 10 images)"
                    head -n 10 images.txt | sed 's/^/- /' || true
                  } >> "$GITHUB_STEP_SUMMARY"

            - name: Cache Trivy DB
              uses: actions/cache@v4
              with:
                  path: |
                      ~/.cache/trivy
                  key: trivy-db-${{ runner.os }}-${{ github.run_id }}
                  restore-keys: |
                      trivy-db-${{ runner.os }}-

            - name: Install Trivy (CLI)
              run: |
                  set -euo pipefail
                  curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh \
                    | sudo sh -s -- -b /usr/local/bin

            - name: Scan images with Trivy (CRITICAL only)
              if: steps.collect.outputs.count != '0'
              run: |
                  set -euo pipefail
                  failed=0
                  : > trivy.log
                  while read -r img; do
                    [[ -z "$img" ]] && continue
                    echo "::group::Trivy scan $img"
                    trivy image --scanners vuln --severity CRITICAL --ignore-unfixed --no-progress "$img" 2>&1 | tee -a trivy.log || failed=1
                    echo "::endgroup::"
                  done < images.txt
                  (( failed == 0 ))

            - name: Summary
              if: always()
              run: |
                  {
                    echo "### üõ° Security (images)"
                    if [[ "${{ job.status }}" == "success" ]]; then
                      echo "- Trivy scan ‚úÖ ‚Äî no CRITICAL vulns found"
                    else
                      echo "- Trivy scan ‚ùå ‚Äî CRITICAL vulns detected"
                      if [[ -f trivy.log ]]; then
                        echo
                        echo "<details><summary>Trivy output (last lines)</summary>"
                        tail -n 10 trivy.log
                        echo "</details>"
                      fi
                    fi
                  } >> "$GITHUB_STEP_SUMMARY"
